export type Difficulty = 'easy' | 'medium' | 'hard';

export type Snippet = {
	id: string;
	title: string;
	language: string;
	difficulty: Difficulty;
	category: string;
	code: string;
	source?: string;
	sourceUrl?: string;
};

export const SNIPPETS: Snippet[] = [
	{
		id: 'ts-add',
		title: 'Add Two Numbers',
		language: 'typescript',
		difficulty: 'easy',
		category: 'basics',
		code: ['function add(a: number, b: number): number {', '  return a + b;', '}', ''].join('\n'),
		source: 'TypeScript',
	},
	{
		id: 'ts-binary-search',
		title: 'Binary Search (Iterative)',
		language: 'typescript',
		difficulty: 'medium',
		category: 'search',
		code: [
			'function binarySearch(nums: number[], target: number): number {',
			'  let left = 0;',
			'  let right = nums.length - 1;',
			'',
			'  while (left <= right) {',
			'    const mid = Math.floor((left + right) / 2);',
			'    if (nums[mid] === target) return mid;',
			'    if (nums[mid] < target) left = mid + 1;',
			'    else right = mid - 1;',
			'  }',
			'',
			'  return -1;',
			'}',
			'',
		].join('\n'),
		source: 'TypeScript',
	},
	{
		id: 'ts-quicksort',
		title: 'Quicksort (Recursive)',
		language: 'typescript',
		difficulty: 'medium',
		category: 'sorting',
		code: [
			'function quicksort(nums: number[]): number[] {',
			'  if (nums.length <= 1) return nums;',
			'  const pivot = nums[Math.floor(nums.length / 2)];',
			'  const left = nums.filter((n) => n < pivot);',
			'  const middle = nums.filter((n) => n === pivot);',
			'  const right = nums.filter((n) => n > pivot);',
			'  return [...quicksort(left), ...middle, ...quicksort(right)];',
			'}',
			'',
		].join('\n'),
		source: 'TypeScript',
	},
	{
		id: 'ts-linked-list',
		title: 'Singly Linked List',
		language: 'typescript',
		difficulty: 'medium',
		category: 'data-structure',
		code: [
			'class ListNode {',
			'  value: number;',
			'  next: ListNode | null;',
			'',
			'  constructor(value: number, next: ListNode | null = null) {',
			'    this.value = value;',
			'    this.next = next;',
			'  }',
			'}',
			'',
			'class LinkedList {',
			'  head: ListNode | null = null;',
			'',
			'  append(value: number) {',
			'    const node = new ListNode(value);',
			'    if (!this.head) {',
			'      this.head = node;',
			'      return;',
			'    }',
			'    let current = this.head;',
			'    while (current.next) current = current.next;',
			'    current.next = node;',
			'  }',
			'}',
			'',
		].join('\n'),
		source: 'TypeScript',
	},
	{
		id: 'py-bfs',
		title: 'Breadth First Search',
		language: 'python',
		difficulty: 'medium',
		category: 'graph',
		code: [
			'from collections import deque',
			'',
			'def bfs(graph, start):',
			'    visited = set([start])',
			'    queue = deque([start])',
			'',
			'    while queue:',
			'        node = queue.popleft()',
			'        for neighbor in graph.get(node, []):',
			'            if neighbor not in visited:',
			'                visited.add(neighbor)',
			'                queue.append(neighbor)',
			'',
			'    return visited',
			'',
		].join('\n'),
		source: 'Python',
	},
	{
		id: 'py-merge-sort',
		title: 'Merge Sort',
		language: 'python',
		difficulty: 'medium',
		category: 'sorting',
		code: [
			'def merge_sort(nums):',
			'    if len(nums) <= 1:',
			'        return nums',
			'',
			'    mid = len(nums) // 2',
			'    left = merge_sort(nums[:mid])',
			'    right = merge_sort(nums[mid:])',
			'',
			'    result = []',
			'    i = 0',
			'    j = 0',
			'',
			'    while i < len(left) and j < len(right):',
			'        if left[i] < right[j]:',
			'            result.append(left[i])',
			'            i += 1',
			'        else:',
			'            result.append(right[j])',
			'            j += 1',
			'',
			'    result.extend(left[i:])',
			'    result.extend(right[j:])',
			'    return result',
			'',
		].join('\n'),
		source: 'Python',
	},
	{
		id: 'py-trie',
		title: 'Trie Insert/Search',
		language: 'python',
		difficulty: 'hard',
		category: 'data-structure',
		code: [
			'class TrieNode:',
			'    def __init__(self):',
			'        self.children = {}',
			'        self.is_end = False',
			'',
			'class Trie:',
			'    def __init__(self):',
			'        self.root = TrieNode()',
			'',
			'    def insert(self, word):',
			'        node = self.root',
			'        for ch in word:',
			'            if ch not in node.children:',
			'                node.children[ch] = TrieNode()',
			'            node = node.children[ch]',
			'        node.is_end = True',
			'',
			'    def search(self, word):',
			'        node = self.root',
			'        for ch in word:',
			'            if ch not in node.children:',
			'                return False',
			'            node = node.children[ch]',
			'        return node.is_end',
			'',
		].join('\n'),
		source: 'Python',
	},
	{
		id: 'go-heap',
		title: 'Min Heap (Push/Pop)',
		language: 'go',
		difficulty: 'hard',
		category: 'data-structure',
		code: [
			'type MinHeap struct {',
			'  data []int',
			'}',
			'',
			'func (h *MinHeap) Push(value int) {',
			'  h.data = append(h.data, value)',
			'  i := len(h.data) - 1',
			'  for i > 0 {',
			'    parent := (i - 1) / 2',
			'    if h.data[parent] <= h.data[i] {',
			'      break',
			'    }',
			'    h.data[parent], h.data[i] = h.data[i], h.data[parent]',
			'    i = parent',
			'  }',
			'}',
			'',
			'func (h *MinHeap) Pop() int {',
			'  if len(h.data) == 0 {',
			'    return 0',
			'  }',
			'  root := h.data[0]',
			'  last := h.data[len(h.data)-1]',
			'  h.data = h.data[:len(h.data)-1]',
			'  if len(h.data) == 0 {',
			'    return root',
			'  }',
			'  h.data[0] = last',
			'  i := 0',
			'  for {',
			'    left := i*2 + 1',
			'    right := i*2 + 2',
			'    smallest := i',
			'    if left < len(h.data) && h.data[left] < h.data[smallest] {',
			'      smallest = left',
			'    }',
			'    if right < len(h.data) && h.data[right] < h.data[smallest] {',
			'      smallest = right',
			'    }',
			'    if smallest == i {',
			'      break',
			'    }',
			'    h.data[smallest], h.data[i] = h.data[i], h.data[smallest]',
			'    i = smallest',
			'  }',
			'  return root',
			'}',
			'',
		].join('\n'),
		source: 'Go',
	},
	{
		id: 'go-hashmap',
		title: 'Hash Map with Buckets',
		language: 'go',
		difficulty: 'medium',
		category: 'data-structure',
		code: [
			'type Entry struct {',
			'  key string',
			'  value int',
			'  next *Entry',
			'}',
			'',
			'const bucketCount = 8',
			'',
			'func hash(key string) int {',
			'  sum := 0',
			'  for _, ch := range key {',
			'    sum += int(ch)',
			'  }',
			'  return sum % bucketCount',
			'}',
			'',
			'func put(buckets []*Entry, key string, value int) {',
			'  idx := hash(key)',
			'  head := buckets[idx]',
			'  for node := head; node != nil; node = node.next {',
			'    if node.key == key {',
			'      node.value = value',
			'      return',
			'    }',
			'  }',
			'  buckets[idx] = &Entry{key: key, value: value, next: head}',
			'}',
			'',
		].join('\n'),
		source: 'Go',
	},
	{
		id: 'rs-binary-tree',
		title: 'Binary Tree Depth',
		language: 'rust',
		difficulty: 'medium',
		category: 'tree',
		code: [
			'use std::cell::RefCell;',
			'use std::rc::Rc;',
			'',
			'#[derive(Debug)]',
			'struct Node {',
			'  val: i32,',
			'  left: Option<Rc<RefCell<Node>>>,',
			'  right: Option<Rc<RefCell<Node>>>,',
			'}',
			'',
			'fn max_depth(root: Option<Rc<RefCell<Node>>>) -> i32 {',
			'  match root {',
			'    Some(node) => {',
			'      let node_ref = node.borrow();',
			'      let left = max_depth(node_ref.left.clone());',
			'      let right = max_depth(node_ref.right.clone());',
			'      1 + left.max(right)',
			'    }',
			'    None => 0,',
			'  }',
			'}',
			'',
		].join('\n'),
		source: 'Rust',
	},
	{
		id: 'java-dijkstra',
		title: 'Dijkstra Shortest Path',
		language: 'java',
		difficulty: 'hard',
		category: 'graph',
		code: [
			'import java.util.*;',
			'',
			'class Edge {',
			'  int to;',
			'  int weight;',
			'  Edge(int to, int weight) {',
			'    this.to = to;',
			'    this.weight = weight;',
			'  }',
			'}',
			'',
			'int[] dijkstra(List<List<Edge>> graph, int start) {',
			'  int n = graph.size();',
			'  int[] dist = new int[n];',
			'  Arrays.fill(dist, Integer.MAX_VALUE);',
			'  dist[start] = 0;',
			'',
			'  PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));',
			'  pq.add(new int[] {0, start});',
			'',
			'  while (!pq.isEmpty()) {',
			'    int[] current = pq.poll();',
			'    int d = current[0];',
			'    int node = current[1];',
			'    if (d > dist[node]) continue;',
			'',
			'    for (Edge edge : graph.get(node)) {',
			'      int next = edge.to;',
			'      int nd = d + edge.weight;',
			'      if (nd < dist[next]) {',
			'        dist[next] = nd;',
			'        pq.add(new int[] {nd, next});',
			'      }',
			'    }',
			'  }',
			'',
			'  return dist;',
			'}',
			'',
		].join('\n'),
		source: 'Java',
	},
	{
		id: 'c-stack',
		title: 'Stack Push/Pop',
		language: 'c',
		difficulty: 'easy',
		category: 'data-structure',
		code: [
			'#include <stdio.h>',
			'',
			'#define MAX 16',
			'',
			'int stack[MAX];',
			'int top = -1;',
			'',
			'void push(int value) {',
			'  if (top >= MAX - 1) return;',
			'  stack[++top] = value;',
			'}',
			'',
			'int pop(void) {',
			'  if (top < 0) return -1;',
			'  return stack[top--];',
			'}',
			'',
		].join('\n'),
		source: 'C',
	},
	{
		id: 'c-queue',
		title: 'Circular Queue',
		language: 'c',
		difficulty: 'medium',
		category: 'data-structure',
		code: [
			'#include <stdio.h>',
			'',
			'#define SIZE 8',
			'',
			'int queue[SIZE];',
			'int head = 0;',
			'int tail = 0;',
			'int count = 0;',
			'',
			'void enqueue(int value) {',
			'  if (count == SIZE) return;',
			'  queue[tail] = value;',
			'  tail = (tail + 1) % SIZE;',
			'  count++;',
			'}',
			'',
			'int dequeue(void) {',
			'  if (count == 0) return -1;',
			'  int value = queue[head];',
			'  head = (head + 1) % SIZE;',
			'  count--;',
			'  return value;',
			'}',
			'',
		].join('\n'),
		source: 'C',
	},
];
